// This file is automatically generated. Do not modify.

package cassandra

import (
	"fmt"
	"strconv"
)

const (
	Version = "19.37.0"
)

type Compression int32

const (
	CompressionGzip Compression = 1
	CompressionNone Compression = 2
)

var (
	CompressionByName = map[string]Compression{
		"Compression.GZIP": CompressionGzip,
		"Compression.NONE": CompressionNone,
	}
	CompressionByValue = map[Compression]string{
		CompressionGzip: "Compression.GZIP",
		CompressionNone: "Compression.NONE",
	}
)

func (e Compression) String() string {
	name := CompressionByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value Compression(%d)", e)
	}
	return name
}

func (e Compression) MarshalJSON() ([]byte, error) {
	name := CompressionByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *Compression) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = Compression(CompressionByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = Compression(i)
	return err
}

type ConsistencyLevel int32

const (
	ConsistencyLevelAll         ConsistencyLevel = 5
	ConsistencyLevelAny         ConsistencyLevel = 6
	ConsistencyLevelEachQuorum  ConsistencyLevel = 4
	ConsistencyLevelLocalQuorum ConsistencyLevel = 3
	ConsistencyLevelLocalSerial ConsistencyLevel = 10
	ConsistencyLevelOne         ConsistencyLevel = 1
	ConsistencyLevelQuorum      ConsistencyLevel = 2
	ConsistencyLevelSerial      ConsistencyLevel = 9
	ConsistencyLevelThree       ConsistencyLevel = 8
	ConsistencyLevelTwo         ConsistencyLevel = 7
)

var (
	ConsistencyLevelByName = map[string]ConsistencyLevel{
		"ConsistencyLevel.ALL":          ConsistencyLevelAll,
		"ConsistencyLevel.ANY":          ConsistencyLevelAny,
		"ConsistencyLevel.EACH_QUORUM":  ConsistencyLevelEachQuorum,
		"ConsistencyLevel.LOCAL_QUORUM": ConsistencyLevelLocalQuorum,
		"ConsistencyLevel.LOCAL_SERIAL": ConsistencyLevelLocalSerial,
		"ConsistencyLevel.ONE":          ConsistencyLevelOne,
		"ConsistencyLevel.QUORUM":       ConsistencyLevelQuorum,
		"ConsistencyLevel.SERIAL":       ConsistencyLevelSerial,
		"ConsistencyLevel.THREE":        ConsistencyLevelThree,
		"ConsistencyLevel.TWO":          ConsistencyLevelTwo,
	}
	ConsistencyLevelByValue = map[ConsistencyLevel]string{
		ConsistencyLevelAll:         "ConsistencyLevel.ALL",
		ConsistencyLevelAny:         "ConsistencyLevel.ANY",
		ConsistencyLevelEachQuorum:  "ConsistencyLevel.EACH_QUORUM",
		ConsistencyLevelLocalQuorum: "ConsistencyLevel.LOCAL_QUORUM",
		ConsistencyLevelLocalSerial: "ConsistencyLevel.LOCAL_SERIAL",
		ConsistencyLevelOne:         "ConsistencyLevel.ONE",
		ConsistencyLevelQuorum:      "ConsistencyLevel.QUORUM",
		ConsistencyLevelSerial:      "ConsistencyLevel.SERIAL",
		ConsistencyLevelThree:       "ConsistencyLevel.THREE",
		ConsistencyLevelTwo:         "ConsistencyLevel.TWO",
	}
)

func (e ConsistencyLevel) String() string {
	name := ConsistencyLevelByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value ConsistencyLevel(%d)", e)
	}
	return name
}

func (e ConsistencyLevel) MarshalJSON() ([]byte, error) {
	name := ConsistencyLevelByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *ConsistencyLevel) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = ConsistencyLevel(ConsistencyLevelByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = ConsistencyLevel(i)
	return err
}

type CqlResultType int32

const (
	CqlResultTypeInt  CqlResultType = 3
	CqlResultTypeRows CqlResultType = 1
	CqlResultTypeVoid CqlResultType = 2
)

var (
	CqlResultTypeByName = map[string]CqlResultType{
		"CqlResultType.INT":  CqlResultTypeInt,
		"CqlResultType.ROWS": CqlResultTypeRows,
		"CqlResultType.VOID": CqlResultTypeVoid,
	}
	CqlResultTypeByValue = map[CqlResultType]string{
		CqlResultTypeInt:  "CqlResultType.INT",
		CqlResultTypeRows: "CqlResultType.ROWS",
		CqlResultTypeVoid: "CqlResultType.VOID",
	}
)

func (e CqlResultType) String() string {
	name := CqlResultTypeByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value CqlResultType(%d)", e)
	}
	return name
}

func (e CqlResultType) MarshalJSON() ([]byte, error) {
	name := CqlResultTypeByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *CqlResultType) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = CqlResultType(CqlResultTypeByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = CqlResultType(i)
	return err
}

type IndexOperator int32

const (
	IndexOperatorEq  IndexOperator = 0
	IndexOperatorGt  IndexOperator = 2
	IndexOperatorGte IndexOperator = 1
	IndexOperatorLt  IndexOperator = 4
	IndexOperatorLte IndexOperator = 3
)

var (
	IndexOperatorByName = map[string]IndexOperator{
		"IndexOperator.EQ":  IndexOperatorEq,
		"IndexOperator.GT":  IndexOperatorGt,
		"IndexOperator.GTE": IndexOperatorGte,
		"IndexOperator.LT":  IndexOperatorLt,
		"IndexOperator.LTE": IndexOperatorLte,
	}
	IndexOperatorByValue = map[IndexOperator]string{
		IndexOperatorEq:  "IndexOperator.EQ",
		IndexOperatorGt:  "IndexOperator.GT",
		IndexOperatorGte: "IndexOperator.GTE",
		IndexOperatorLt:  "IndexOperator.LT",
		IndexOperatorLte: "IndexOperator.LTE",
	}
)

func (e IndexOperator) String() string {
	name := IndexOperatorByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value IndexOperator(%d)", e)
	}
	return name
}

func (e IndexOperator) MarshalJSON() ([]byte, error) {
	name := IndexOperatorByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *IndexOperator) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = IndexOperator(IndexOperatorByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = IndexOperator(i)
	return err
}

type IndexType int32

const (
	IndexTypeComposites IndexType = 2
	IndexTypeCustom     IndexType = 1
	IndexTypeKeys       IndexType = 0
)

var (
	IndexTypeByName = map[string]IndexType{
		"IndexType.COMPOSITES": IndexTypeComposites,
		"IndexType.CUSTOM":     IndexTypeCustom,
		"IndexType.KEYS":       IndexTypeKeys,
	}
	IndexTypeByValue = map[IndexType]string{
		IndexTypeComposites: "IndexType.COMPOSITES",
		IndexTypeCustom:     "IndexType.CUSTOM",
		IndexTypeKeys:       "IndexType.KEYS",
	}
)

func (e IndexType) String() string {
	name := IndexTypeByValue[e]
	if name == "" {
		name = fmt.Sprintf("Unknown enum value IndexType(%d)", e)
	}
	return name
}

func (e IndexType) MarshalJSON() ([]byte, error) {
	name := IndexTypeByValue[e]
	if name == "" {
		name = strconv.Itoa(int(e))
	}
	return []byte("\"" + name + "\""), nil
}

func (e *IndexType) UnmarshalJSON(b []byte) error {
	st := string(b)
	if st[0] == '"' {
		*e = IndexType(IndexTypeByName[st[1:len(st)-1]])
		return nil
	}
	i, err := strconv.Atoi(st)
	*e = IndexType(i)
	return err
}

type AuthenticationRequest struct {
	Credentials map[string]string `thrift:"1,required" json:"credentials"`
}

type CASResult struct {
	Success       bool      `thrift:"1,required" json:"success"`
	CurrentValues []*Column `thrift:"2" json:"current_values,omitempty"`
}

type CfDef struct {
	Keyspace                     string            `thrift:"1,required" json:"keyspace"`
	Name                         string            `thrift:"2,required" json:"name"`
	ColumnType                   *string           `thrift:"3" json:"column_type,omitempty"`
	ComparatorType               *string           `thrift:"5" json:"comparator_type,omitempty"`
	SubcomparatorType            *string           `thrift:"6" json:"subcomparator_type,omitempty"`
	Comment                      *string           `thrift:"8" json:"comment,omitempty"`
	ReadRepairChance             *float64          `thrift:"12" json:"read_repair_chance,omitempty"`
	ColumnMetadata               []*ColumnDef      `thrift:"13" json:"column_metadata,omitempty"`
	GcGraceSeconds               *int32            `thrift:"14" json:"gc_grace_seconds,omitempty"`
	DefaultValidationClass       *string           `thrift:"15" json:"default_validation_class,omitempty"`
	Id                           *int32            `thrift:"16" json:"id,omitempty"`
	MinCompactionThreshold       *int32            `thrift:"17" json:"min_compaction_threshold,omitempty"`
	MaxCompactionThreshold       *int32            `thrift:"18" json:"max_compaction_threshold,omitempty"`
	ReplicateOnWrite             *bool             `thrift:"24" json:"replicate_on_write,omitempty"`
	KeyValidationClass           *string           `thrift:"26" json:"key_validation_class,omitempty"`
	KeyAlias                     []byte            `thrift:"28" json:"key_alias,omitempty"`
	CompactionStrategy           *string           `thrift:"29" json:"compaction_strategy,omitempty"`
	CompactionStrategyOptions    map[string]string `thrift:"30" json:"compaction_strategy_options,omitempty"`
	CompressionOptions           map[string]string `thrift:"32" json:"compression_options,omitempty"`
	BloomFilterFpChance          *float64          `thrift:"33" json:"bloom_filter_fp_chance,omitempty"`
	Caching                      *string           `thrift:"34" json:"caching,omitempty"`
	DclocalReadRepairChance      *float64          `thrift:"37" json:"dclocal_read_repair_chance,omitempty"`
	PopulateIoCacheOnFlush       *bool             `thrift:"38" json:"populate_io_cache_on_flush,omitempty"`
	MemtableFlushPeriodInMs      *int32            `thrift:"39" json:"memtable_flush_period_in_ms,omitempty"`
	DefaultTimeToLive            *int32            `thrift:"40" json:"default_time_to_live,omitempty"`
	IndexInterval                *int32            `thrift:"41" json:"index_interval,omitempty"`
	SpeculativeRetry             *string           `thrift:"42" json:"speculative_retry,omitempty"`
	Triggers                     []*TriggerDef     `thrift:"43" json:"triggers,omitempty"`
	RowCacheSize                 *float64          `thrift:"9" json:"row_cache_size,omitempty"`
	KeyCacheSize                 *float64          `thrift:"11" json:"key_cache_size,omitempty"`
	RowCacheSavePeriodInSeconds  *int32            `thrift:"19" json:"row_cache_save_period_in_seconds,omitempty"`
	KeyCacheSavePeriodInSeconds  *int32            `thrift:"20" json:"key_cache_save_period_in_seconds,omitempty"`
	MemtableFlushAfterMins       *int32            `thrift:"21" json:"memtable_flush_after_mins,omitempty"`
	MemtableThroughputInMb       *int32            `thrift:"22" json:"memtable_throughput_in_mb,omitempty"`
	MemtableOperationsInMillions *float64          `thrift:"23" json:"memtable_operations_in_millions,omitempty"`
	MergeShardsChance            *float64          `thrift:"25" json:"merge_shards_chance,omitempty"`
	RowCacheProvider             *string           `thrift:"27" json:"row_cache_provider,omitempty"`
	RowCacheKeysToSave           *int32            `thrift:"31" json:"row_cache_keys_to_save,omitempty"`
}

type CfSplit struct {
	StartToken string `thrift:"1,required" json:"start_token"`
	EndToken   string `thrift:"2,required" json:"end_token"`
	RowCount   int64  `thrift:"3,required" json:"row_count"`
}

type Column struct {
	Name      []byte `thrift:"1,required" json:"name"`
	Value     []byte `thrift:"2" json:"value,omitempty"`
	Timestamp *int64 `thrift:"3" json:"timestamp,omitempty"`
	Ttl       *int32 `thrift:"4" json:"ttl,omitempty"`
}

type ColumnDef struct {
	Name            []byte            `thrift:"1,required" json:"name"`
	ValidationClass string            `thrift:"2,required" json:"validation_class"`
	IndexType       *IndexType        `thrift:"3" json:"index_type,omitempty"`
	IndexName       *string           `thrift:"4" json:"index_name,omitempty"`
	IndexOptions    map[string]string `thrift:"5" json:"index_options,omitempty"`
}

type ColumnOrSuperColumn struct {
	Column             *Column             `thrift:"1" json:"column,omitempty"`
	SuperColumn        *SuperColumn        `thrift:"2" json:"super_column,omitempty"`
	CounterColumn      *CounterColumn      `thrift:"3" json:"counter_column,omitempty"`
	CounterSuperColumn *CounterSuperColumn `thrift:"4" json:"counter_super_column,omitempty"`
}

type ColumnParent struct {
	ColumnFamily string `thrift:"3,required" json:"column_family"`
	SuperColumn  []byte `thrift:"4" json:"super_column,omitempty"`
}

type ColumnPath struct {
	ColumnFamily string `thrift:"3,required" json:"column_family"`
	SuperColumn  []byte `thrift:"4" json:"super_column,omitempty"`
	Column       []byte `thrift:"5" json:"column,omitempty"`
}

type CounterColumn struct {
	Name  []byte `thrift:"1,required" json:"name"`
	Value int64  `thrift:"2,required" json:"value"`
}

type CounterSuperColumn struct {
	Name    []byte           `thrift:"1,required" json:"name"`
	Columns []*CounterColumn `thrift:"2,required" json:"columns"`
}

type CqlMetadata struct {
	NameTypes        map[string]string `thrift:"1,required" json:"name_types"`
	ValueTypes       map[string]string `thrift:"2,required" json:"value_types"`
	DefaultNameType  string            `thrift:"3,required" json:"default_name_type"`
	DefaultValueType string            `thrift:"4,required" json:"default_value_type"`
}

type CqlPreparedResult struct {
	ItemId        int32    `thrift:"1,required" json:"itemId"`
	Count         int32    `thrift:"2,required" json:"count"`
	VariableTypes []string `thrift:"3" json:"variable_types,omitempty"`
	VariableNames []string `thrift:"4" json:"variable_names,omitempty"`
}

type CqlResult struct {
	Type   CqlResultType `thrift:"1,required" json:"type"`
	Rows   []*CqlRow     `thrift:"2" json:"rows,omitempty"`
	Num    *int32        `thrift:"3" json:"num,omitempty"`
	Schema *CqlMetadata  `thrift:"4" json:"schema,omitempty"`
}

type CqlRow struct {
	Key     []byte    `thrift:"1,required" json:"key"`
	Columns []*Column `thrift:"2,required" json:"columns"`
}

type Deletion struct {
	Timestamp   *int64          `thrift:"1" json:"timestamp,omitempty"`
	SuperColumn []byte          `thrift:"2" json:"super_column,omitempty"`
	Predicate   *SlicePredicate `thrift:"3" json:"predicate,omitempty"`
}

type EndpointDetails struct {
	Host       string  `thrift:"1,required" json:"host"`
	Datacenter string  `thrift:"2,required" json:"datacenter"`
	Rack       *string `thrift:"3" json:"rack,omitempty"`
}

type IndexClause struct {
	Expressions []*IndexExpression `thrift:"1,required" json:"expressions"`
	StartKey    []byte             `thrift:"2,required" json:"start_key"`
	Count       int32              `thrift:"3,required" json:"count"`
}

type IndexExpression struct {
	ColumnName []byte        `thrift:"1,required" json:"column_name"`
	Op         IndexOperator `thrift:"2,required" json:"op"`
	Value      []byte        `thrift:"3,required" json:"value"`
}

type KeyCount struct {
	Key   []byte `thrift:"1,required" json:"key"`
	Count int32  `thrift:"2,required" json:"count"`
}

type KeyRange struct {
	StartKey   []byte             `thrift:"1" json:"start_key,omitempty"`
	EndKey     []byte             `thrift:"2" json:"end_key,omitempty"`
	StartToken *string            `thrift:"3" json:"start_token,omitempty"`
	EndToken   *string            `thrift:"4" json:"end_token,omitempty"`
	RowFilter  []*IndexExpression `thrift:"6" json:"row_filter,omitempty"`
	Count      int32              `thrift:"5,required" json:"count"`
}

type KeySlice struct {
	Key     []byte                 `thrift:"1,required" json:"key"`
	Columns []*ColumnOrSuperColumn `thrift:"2,required" json:"columns"`
}

type KsDef struct {
	Name              string            `thrift:"1,required" json:"name"`
	StrategyClass     string            `thrift:"2,required" json:"strategy_class"`
	StrategyOptions   map[string]string `thrift:"3" json:"strategy_options,omitempty"`
	ReplicationFactor *int32            `thrift:"4" json:"replication_factor,omitempty"`
	CfDefs            []*CfDef          `thrift:"5,required" json:"cf_defs"`
	DurableWrites     *bool             `thrift:"6" json:"durable_writes,omitempty"`
}

type Mutation struct {
	ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"1" json:"column_or_supercolumn,omitempty"`
	Deletion            *Deletion            `thrift:"2" json:"deletion,omitempty"`
}

type SlicePredicate struct {
	ColumnNames [][]byte    `thrift:"1" json:"column_names,omitempty"`
	SliceRange  *SliceRange `thrift:"2" json:"slice_range,omitempty"`
}

type SliceRange struct {
	Start    []byte `thrift:"1,required" json:"start"`
	Finish   []byte `thrift:"2,required" json:"finish"`
	Reversed bool   `thrift:"3,required" json:"reversed"`
	Count    int32  `thrift:"4,required" json:"count"`
}

type SuperColumn struct {
	Name    []byte    `thrift:"1,required" json:"name"`
	Columns []*Column `thrift:"2,required" json:"columns"`
}

type TokenRange struct {
	StartToken      string             `thrift:"1,required" json:"start_token"`
	EndToken        string             `thrift:"2,required" json:"end_token"`
	Endpoints       []string           `thrift:"3,required" json:"endpoints"`
	RpcEndpoints    []string           `thrift:"4" json:"rpc_endpoints,omitempty"`
	EndpointDetails []*EndpointDetails `thrift:"5" json:"endpoint_details,omitempty"`
}

type TriggerDef struct {
	Name    string            `thrift:"1,required" json:"name"`
	Options map[string]string `thrift:"2,required" json:"options"`
}

type AuthenticationException struct {
	Why string `thrift:"1,required" json:"why"`
}

func (e *AuthenticationException) Error() string {
	return fmt.Sprintf("AuthenticationException{Why: %+v}", e.Why)
}

type AuthorizationException struct {
	Why string `thrift:"1,required" json:"why"`
}

func (e *AuthorizationException) Error() string {
	return fmt.Sprintf("AuthorizationException{Why: %+v}", e.Why)
}

type InvalidRequestException struct {
	Why string `thrift:"1,required" json:"why"`
}

func (e *InvalidRequestException) Error() string {
	return fmt.Sprintf("InvalidRequestException{Why: %+v}", e.Why)
}

type NotFoundException struct {
}

func (e *NotFoundException) Error() string {
	return "NotFoundException{}"
}

type SchemaDisagreementException struct {
}

func (e *SchemaDisagreementException) Error() string {
	return "SchemaDisagreementException{}"
}

type TimedOutException struct {
	AcknowledgedBy         *int32 `thrift:"1" json:"acknowledged_by,omitempty"`
	AcknowledgedByBatchlog *bool  `thrift:"2" json:"acknowledged_by_batchlog,omitempty"`
	PaxosInProgress        *bool  `thrift:"3" json:"paxos_in_progress,omitempty"`
}

func (e *TimedOutException) Error() string {
	return fmt.Sprintf("TimedOutException{AcknowledgedBy: %+v, AcknowledgedByBatchlog: %+v, PaxosInProgress: %+v}", e.AcknowledgedBy, e.AcknowledgedByBatchlog, e.PaxosInProgress)
}

type UnavailableException struct {
}

func (e *UnavailableException) Error() string {
	return "UnavailableException{}"
}

type RPCClient interface {
	Call(method string, request interface{}, response interface{}) error
}

type Cassandra interface {
	Add(Key []byte, ColumnParent *ColumnParent, Column *CounterColumn, ConsistencyLevel ConsistencyLevel) error
	AtomicBatchMutate(MutationMap map[string]map[string][]*Mutation, ConsistencyLevel ConsistencyLevel) error
	BatchMutate(MutationMap map[string]map[string][]*Mutation, ConsistencyLevel ConsistencyLevel) error
	Cas(Key []byte, ColumnFamily string, Expected []*Column, Updates []*Column, SerialConsistencyLevel ConsistencyLevel, CommitConsistencyLevel ConsistencyLevel) (*CASResult, error)
	DescribeClusterName() (string, error)
	DescribeKeyspace(Keyspace string) (*KsDef, error)
	DescribeKeyspaces() ([]*KsDef, error)
	DescribePartitioner() (string, error)
	DescribeRing(Keyspace string) ([]*TokenRange, error)
	DescribeSchemaVersions() (map[string][]string, error)
	DescribeSnitch() (string, error)
	DescribeSplits(CfName string, StartToken string, EndToken string, KeysPerSplit int32) ([]string, error)
	DescribeSplitsEx(CfName string, StartToken string, EndToken string, KeysPerSplit int32) ([]*CfSplit, error)
	DescribeTokenMap() (map[string]string, error)
	DescribeVersion() (string, error)
	ExecuteCql3Query(Query []byte, Compression Compression, Consistency ConsistencyLevel) (*CqlResult, error)
	ExecuteCqlQuery(Query []byte, Compression Compression) (*CqlResult, error)
	ExecutePreparedCql3Query(ItemId int32, Values [][]byte, Consistency ConsistencyLevel) (*CqlResult, error)
	ExecutePreparedCqlQuery(ItemId int32, Values [][]byte) (*CqlResult, error)
	Get(Key []byte, ColumnPath *ColumnPath, ConsistencyLevel ConsistencyLevel) (*ColumnOrSuperColumn, error)
	GetCount(Key []byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (int32, error)
	GetIndexedSlices(ColumnParent *ColumnParent, IndexClause *IndexClause, ColumnPredicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error)
	GetPagedSlice(ColumnFamily string, Range *KeyRange, StartColumn []byte, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error)
	GetRangeSlices(ColumnParent *ColumnParent, Predicate *SlicePredicate, Range *KeyRange, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error)
	GetSlice(Key []byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) ([]*ColumnOrSuperColumn, error)
	Insert(Key []byte, ColumnParent *ColumnParent, Column *Column, ConsistencyLevel ConsistencyLevel) error
	Login(AuthRequest *AuthenticationRequest) error
	MultigetCount(Keys [][]byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (map[string]int32, error)
	MultigetSlice(Keys [][]byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (map[string][]*ColumnOrSuperColumn, error)
	PrepareCql3Query(Query []byte, Compression Compression) (*CqlPreparedResult, error)
	PrepareCqlQuery(Query []byte, Compression Compression) (*CqlPreparedResult, error)
	Remove(Key []byte, ColumnPath *ColumnPath, Timestamp int64, ConsistencyLevel ConsistencyLevel) error
	RemoveCounter(Key []byte, Path *ColumnPath, ConsistencyLevel ConsistencyLevel) error
	SetCqlVersion(Version string) error
	SetKeyspace(Keyspace string) error
	SystemAddColumnFamily(CfDef *CfDef) (string, error)
	SystemAddKeyspace(KsDef *KsDef) (string, error)
	SystemDropColumnFamily(ColumnFamily string) (string, error)
	SystemDropKeyspace(Keyspace string) (string, error)
	SystemUpdateColumnFamily(CfDef *CfDef) (string, error)
	SystemUpdateKeyspace(KsDef *KsDef) (string, error)
	TraceNextQuery() ([]byte, error)
	Truncate(Cfname string) error
}

type CassandraServer struct {
	Implementation Cassandra
}

func (s *CassandraServer) Add(req *CassandraAddRequest, res *CassandraAddResponse) error {
	err := s.Implementation.Add(req.Key, req.ColumnParent, req.Column, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) AtomicBatchMutate(req *CassandraAtomicBatchMutateRequest, res *CassandraAtomicBatchMutateResponse) error {
	err := s.Implementation.AtomicBatchMutate(req.MutationMap, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) BatchMutate(req *CassandraBatchMutateRequest, res *CassandraBatchMutateResponse) error {
	err := s.Implementation.BatchMutate(req.MutationMap, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) Cas(req *CassandraCasRequest, res *CassandraCasResponse) error {
	val, err := s.Implementation.Cas(req.Key, req.ColumnFamily, req.Expected, req.Updates, req.SerialConsistencyLevel, req.CommitConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeClusterName(req *CassandraDescribeClusterNameRequest, res *CassandraDescribeClusterNameResponse) error {
	val, err := s.Implementation.DescribeClusterName()
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeKeyspace(req *CassandraDescribeKeyspaceRequest, res *CassandraDescribeKeyspaceResponse) error {
	val, err := s.Implementation.DescribeKeyspace(req.Keyspace)
	switch e := err.(type) {
	case *NotFoundException:
		res.Nfe = e
		err = nil
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeKeyspaces(req *CassandraDescribeKeyspacesRequest, res *CassandraDescribeKeyspacesResponse) error {
	val, err := s.Implementation.DescribeKeyspaces()
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribePartitioner(req *CassandraDescribePartitionerRequest, res *CassandraDescribePartitionerResponse) error {
	val, err := s.Implementation.DescribePartitioner()
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeRing(req *CassandraDescribeRingRequest, res *CassandraDescribeRingResponse) error {
	val, err := s.Implementation.DescribeRing(req.Keyspace)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeSchemaVersions(req *CassandraDescribeSchemaVersionsRequest, res *CassandraDescribeSchemaVersionsResponse) error {
	val, err := s.Implementation.DescribeSchemaVersions()
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeSnitch(req *CassandraDescribeSnitchRequest, res *CassandraDescribeSnitchResponse) error {
	val, err := s.Implementation.DescribeSnitch()
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeSplits(req *CassandraDescribeSplitsRequest, res *CassandraDescribeSplitsResponse) error {
	val, err := s.Implementation.DescribeSplits(req.CfName, req.StartToken, req.EndToken, req.KeysPerSplit)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeSplitsEx(req *CassandraDescribeSplitsExRequest, res *CassandraDescribeSplitsExResponse) error {
	val, err := s.Implementation.DescribeSplitsEx(req.CfName, req.StartToken, req.EndToken, req.KeysPerSplit)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeTokenMap(req *CassandraDescribeTokenMapRequest, res *CassandraDescribeTokenMapResponse) error {
	val, err := s.Implementation.DescribeTokenMap()
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) DescribeVersion(req *CassandraDescribeVersionRequest, res *CassandraDescribeVersionResponse) error {
	val, err := s.Implementation.DescribeVersion()
	res.Value = val
	return err
}

func (s *CassandraServer) ExecuteCql3Query(req *CassandraExecuteCql3QueryRequest, res *CassandraExecuteCql3QueryResponse) error {
	val, err := s.Implementation.ExecuteCql3Query(req.Query, req.Compression, req.Consistency)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) ExecuteCqlQuery(req *CassandraExecuteCqlQueryRequest, res *CassandraExecuteCqlQueryResponse) error {
	val, err := s.Implementation.ExecuteCqlQuery(req.Query, req.Compression)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) ExecutePreparedCql3Query(req *CassandraExecutePreparedCql3QueryRequest, res *CassandraExecutePreparedCql3QueryResponse) error {
	val, err := s.Implementation.ExecutePreparedCql3Query(req.ItemId, req.Values, req.Consistency)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) ExecutePreparedCqlQuery(req *CassandraExecutePreparedCqlQueryRequest, res *CassandraExecutePreparedCqlQueryResponse) error {
	val, err := s.Implementation.ExecutePreparedCqlQuery(req.ItemId, req.Values)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) Get(req *CassandraGetRequest, res *CassandraGetResponse) error {
	val, err := s.Implementation.Get(req.Key, req.ColumnPath, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *NotFoundException:
		res.Nfe = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) GetCount(req *CassandraGetCountRequest, res *CassandraGetCountResponse) error {
	val, err := s.Implementation.GetCount(req.Key, req.ColumnParent, req.Predicate, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) GetIndexedSlices(req *CassandraGetIndexedSlicesRequest, res *CassandraGetIndexedSlicesResponse) error {
	val, err := s.Implementation.GetIndexedSlices(req.ColumnParent, req.IndexClause, req.ColumnPredicate, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) GetPagedSlice(req *CassandraGetPagedSliceRequest, res *CassandraGetPagedSliceResponse) error {
	val, err := s.Implementation.GetPagedSlice(req.ColumnFamily, req.Range, req.StartColumn, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) GetRangeSlices(req *CassandraGetRangeSlicesRequest, res *CassandraGetRangeSlicesResponse) error {
	val, err := s.Implementation.GetRangeSlices(req.ColumnParent, req.Predicate, req.Range, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) GetSlice(req *CassandraGetSliceRequest, res *CassandraGetSliceResponse) error {
	val, err := s.Implementation.GetSlice(req.Key, req.ColumnParent, req.Predicate, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) Insert(req *CassandraInsertRequest, res *CassandraInsertResponse) error {
	err := s.Implementation.Insert(req.Key, req.ColumnParent, req.Column, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) Login(req *CassandraLoginRequest, res *CassandraLoginResponse) error {
	err := s.Implementation.Login(req.AuthRequest)
	switch e := err.(type) {
	case *AuthenticationException:
		res.Authnx = e
		err = nil
	case *AuthorizationException:
		res.Authzx = e
		err = nil
	}
	return err
}

func (s *CassandraServer) MultigetCount(req *CassandraMultigetCountRequest, res *CassandraMultigetCountResponse) error {
	val, err := s.Implementation.MultigetCount(req.Keys, req.ColumnParent, req.Predicate, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) MultigetSlice(req *CassandraMultigetSliceRequest, res *CassandraMultigetSliceResponse) error {
	val, err := s.Implementation.MultigetSlice(req.Keys, req.ColumnParent, req.Predicate, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) PrepareCql3Query(req *CassandraPrepareCql3QueryRequest, res *CassandraPrepareCql3QueryResponse) error {
	val, err := s.Implementation.PrepareCql3Query(req.Query, req.Compression)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) PrepareCqlQuery(req *CassandraPrepareCqlQueryRequest, res *CassandraPrepareCqlQueryResponse) error {
	val, err := s.Implementation.PrepareCqlQuery(req.Query, req.Compression)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) Remove(req *CassandraRemoveRequest, res *CassandraRemoveResponse) error {
	err := s.Implementation.Remove(req.Key, req.ColumnPath, req.Timestamp, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) RemoveCounter(req *CassandraRemoveCounterRequest, res *CassandraRemoveCounterResponse) error {
	err := s.Implementation.RemoveCounter(req.Key, req.Path, req.ConsistencyLevel)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

func (s *CassandraServer) SetCqlVersion(req *CassandraSetCqlVersionRequest, res *CassandraSetCqlVersionResponse) error {
	err := s.Implementation.SetCqlVersion(req.Version)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	return err
}

func (s *CassandraServer) SetKeyspace(req *CassandraSetKeyspaceRequest, res *CassandraSetKeyspaceResponse) error {
	err := s.Implementation.SetKeyspace(req.Keyspace)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	}
	return err
}

func (s *CassandraServer) SystemAddColumnFamily(req *CassandraSystemAddColumnFamilyRequest, res *CassandraSystemAddColumnFamilyResponse) error {
	val, err := s.Implementation.SystemAddColumnFamily(req.CfDef)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) SystemAddKeyspace(req *CassandraSystemAddKeyspaceRequest, res *CassandraSystemAddKeyspaceResponse) error {
	val, err := s.Implementation.SystemAddKeyspace(req.KsDef)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) SystemDropColumnFamily(req *CassandraSystemDropColumnFamilyRequest, res *CassandraSystemDropColumnFamilyResponse) error {
	val, err := s.Implementation.SystemDropColumnFamily(req.ColumnFamily)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) SystemDropKeyspace(req *CassandraSystemDropKeyspaceRequest, res *CassandraSystemDropKeyspaceResponse) error {
	val, err := s.Implementation.SystemDropKeyspace(req.Keyspace)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) SystemUpdateColumnFamily(req *CassandraSystemUpdateColumnFamilyRequest, res *CassandraSystemUpdateColumnFamilyResponse) error {
	val, err := s.Implementation.SystemUpdateColumnFamily(req.CfDef)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) SystemUpdateKeyspace(req *CassandraSystemUpdateKeyspaceRequest, res *CassandraSystemUpdateKeyspaceResponse) error {
	val, err := s.Implementation.SystemUpdateKeyspace(req.KsDef)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *SchemaDisagreementException:
		res.Sde = e
		err = nil
	}
	res.Value = val
	return err
}

func (s *CassandraServer) TraceNextQuery(req *CassandraTraceNextQueryRequest, res *CassandraTraceNextQueryResponse) error {
	val, err := s.Implementation.TraceNextQuery()
	res.Value = val
	return err
}

func (s *CassandraServer) Truncate(req *CassandraTruncateRequest, res *CassandraTruncateResponse) error {
	err := s.Implementation.Truncate(req.Cfname)
	switch e := err.(type) {
	case *InvalidRequestException:
		res.Ire = e
		err = nil
	case *UnavailableException:
		res.Ue = e
		err = nil
	case *TimedOutException:
		res.Te = e
		err = nil
	}
	return err
}

type CassandraAddRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Column           *CounterColumn   `thrift:"3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraAddResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraAtomicBatchMutateRequest struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"2,required" json:"consistency_level"`
}

type CassandraAtomicBatchMutateResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraBatchMutateRequest struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"1,required" json:"mutation_map"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"2,required" json:"consistency_level"`
}

type CassandraBatchMutateResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraCasRequest struct {
	Key                    []byte           `thrift:"1,required" json:"key"`
	ColumnFamily           string           `thrift:"2,required" json:"column_family"`
	Expected               []*Column        `thrift:"3,required" json:"expected"`
	Updates                []*Column        `thrift:"4,required" json:"updates"`
	SerialConsistencyLevel ConsistencyLevel `thrift:"5,required" json:"serial_consistency_level"`
	CommitConsistencyLevel ConsistencyLevel `thrift:"6,required" json:"commit_consistency_level"`
}

type CassandraCasResponse struct {
	Value *CASResult               `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraDescribeClusterNameRequest struct {
}

type CassandraDescribeClusterNameResponse struct {
	Value string `thrift:"0,required" json:"value"`
}

type CassandraDescribeKeyspaceRequest struct {
	Keyspace string `thrift:"1,required" json:"keyspace"`
}

type CassandraDescribeKeyspaceResponse struct {
	Value *KsDef                   `thrift:"0" json:"value,omitempty"`
	Nfe   *NotFoundException       `thrift:"1" json:"nfe,omitempty"`
	Ire   *InvalidRequestException `thrift:"2" json:"ire,omitempty"`
}

type CassandraDescribeKeyspacesRequest struct {
}

type CassandraDescribeKeyspacesResponse struct {
	Value []*KsDef                 `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribePartitionerRequest struct {
}

type CassandraDescribePartitionerResponse struct {
	Value string `thrift:"0,required" json:"value"`
}

type CassandraDescribeRingRequest struct {
	Keyspace string `thrift:"1,required" json:"keyspace"`
}

type CassandraDescribeRingResponse struct {
	Value []*TokenRange            `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribeSchemaVersionsRequest struct {
}

type CassandraDescribeSchemaVersionsResponse struct {
	Value map[string][]string      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribeSnitchRequest struct {
}

type CassandraDescribeSnitchResponse struct {
	Value string `thrift:"0,required" json:"value"`
}

type CassandraDescribeSplitsRequest struct {
	CfName       string `thrift:"1,required" json:"cfName"`
	StartToken   string `thrift:"2,required" json:"start_token"`
	EndToken     string `thrift:"3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"4,required" json:"keys_per_split"`
}

type CassandraDescribeSplitsResponse struct {
	Value []string                 `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribeSplitsExRequest struct {
	CfName       string `thrift:"1,required" json:"cfName"`
	StartToken   string `thrift:"2,required" json:"start_token"`
	EndToken     string `thrift:"3,required" json:"end_token"`
	KeysPerSplit int32  `thrift:"4,required" json:"keys_per_split"`
}

type CassandraDescribeSplitsExResponse struct {
	Value []*CfSplit               `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribeTokenMapRequest struct {
}

type CassandraDescribeTokenMapResponse struct {
	Value map[string]string        `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraDescribeVersionRequest struct {
}

type CassandraDescribeVersionResponse struct {
	Value string `thrift:"0,required" json:"value"`
}

type CassandraExecuteCql3QueryRequest struct {
	Query       []byte           `thrift:"1,required" json:"query"`
	Compression Compression      `thrift:"2,required" json:"compression"`
	Consistency ConsistencyLevel `thrift:"3,required" json:"consistency"`
}

type CassandraExecuteCql3QueryResponse struct {
	Value *CqlResult                   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException        `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException           `thrift:"3" json:"te,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"4" json:"sde,omitempty"`
}

type CassandraExecuteCqlQueryRequest struct {
	Query       []byte      `thrift:"1,required" json:"query"`
	Compression Compression `thrift:"2,required" json:"compression"`
}

type CassandraExecuteCqlQueryResponse struct {
	Value *CqlResult                   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException        `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException           `thrift:"3" json:"te,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"4" json:"sde,omitempty"`
}

type CassandraExecutePreparedCql3QueryRequest struct {
	ItemId      int32            `thrift:"1,required" json:"itemId"`
	Values      [][]byte         `thrift:"2,required" json:"values"`
	Consistency ConsistencyLevel `thrift:"3,required" json:"consistency"`
}

type CassandraExecutePreparedCql3QueryResponse struct {
	Value *CqlResult                   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException        `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException           `thrift:"3" json:"te,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"4" json:"sde,omitempty"`
}

type CassandraExecutePreparedCqlQueryRequest struct {
	ItemId int32    `thrift:"1,required" json:"itemId"`
	Values [][]byte `thrift:"2,required" json:"values"`
}

type CassandraExecutePreparedCqlQueryResponse struct {
	Value *CqlResult                   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException        `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException           `thrift:"3" json:"te,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"4" json:"sde,omitempty"`
}

type CassandraGetRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"2,required" json:"column_path"`
	ConsistencyLevel ConsistencyLevel `thrift:"3,required" json:"consistency_level"`
}

type CassandraGetResponse struct {
	Value *ColumnOrSuperColumn     `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Nfe   *NotFoundException       `thrift:"2" json:"nfe,omitempty"`
	Ue    *UnavailableException    `thrift:"3" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"4" json:"te,omitempty"`
}

type CassandraGetCountRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraGetCountResponse struct {
	Value int32                   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraGetIndexedSlicesRequest struct {
	ColumnParent     *ColumnParent    `thrift:"1,required" json:"column_parent"`
	IndexClause      *IndexClause     `thrift:"2,required" json:"index_clause"`
	ColumnPredicate  *SlicePredicate  `thrift:"3,required" json:"column_predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraGetIndexedSlicesResponse struct {
	Value []*KeySlice              `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraGetPagedSliceRequest struct {
	ColumnFamily     string           `thrift:"1,required" json:"column_family"`
	Range            *KeyRange        `thrift:"2,required" json:"range"`
	StartColumn      []byte           `thrift:"3,required" json:"start_column"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraGetPagedSliceResponse struct {
	Value []*KeySlice              `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraGetRangeSlicesRequest struct {
	ColumnParent     *ColumnParent    `thrift:"1,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"2,required" json:"predicate"`
	Range            *KeyRange        `thrift:"3,required" json:"range"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraGetRangeSlicesResponse struct {
	Value []*KeySlice              `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraGetSliceRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraGetSliceResponse struct {
	Value []*ColumnOrSuperColumn   `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraInsertRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Column           *Column          `thrift:"3,required" json:"column"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraInsertResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraLoginRequest struct {
	AuthRequest *AuthenticationRequest `thrift:"1,required" json:"auth_request"`
}

type CassandraLoginResponse struct {
	Authnx *AuthenticationException `thrift:"1" json:"authnx,omitempty"`
	Authzx *AuthorizationException  `thrift:"2" json:"authzx,omitempty"`
}

type CassandraMultigetCountRequest struct {
	Keys             [][]byte         `thrift:"1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraMultigetCountResponse struct {
	Value map[string]int32         `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraMultigetSliceRequest struct {
	Keys             [][]byte         `thrift:"1,required" json:"keys"`
	ColumnParent     *ColumnParent    `thrift:"2,required" json:"column_parent"`
	Predicate        *SlicePredicate  `thrift:"3,required" json:"predicate"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraMultigetSliceResponse struct {
	Value map[string][]*ColumnOrSuperColumn `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException          `thrift:"1" json:"ire,omitempty"`
	Ue    *UnavailableException             `thrift:"2" json:"ue,omitempty"`
	Te    *TimedOutException                `thrift:"3" json:"te,omitempty"`
}

type CassandraPrepareCql3QueryRequest struct {
	Query       []byte      `thrift:"1,required" json:"query"`
	Compression Compression `thrift:"2,required" json:"compression"`
}

type CassandraPrepareCql3QueryResponse struct {
	Value *CqlPreparedResult       `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraPrepareCqlQueryRequest struct {
	Query       []byte      `thrift:"1,required" json:"query"`
	Compression Compression `thrift:"2,required" json:"compression"`
}

type CassandraPrepareCqlQueryResponse struct {
	Value *CqlPreparedResult       `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraRemoveRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	ColumnPath       *ColumnPath      `thrift:"2,required" json:"column_path"`
	Timestamp        int64            `thrift:"3,required" json:"timestamp"`
	ConsistencyLevel ConsistencyLevel `thrift:"4,required" json:"consistency_level"`
}

type CassandraRemoveResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraRemoveCounterRequest struct {
	Key              []byte           `thrift:"1,required" json:"key"`
	Path             *ColumnPath      `thrift:"2,required" json:"path"`
	ConsistencyLevel ConsistencyLevel `thrift:"3,required" json:"consistency_level"`
}

type CassandraRemoveCounterResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraSetCqlVersionRequest struct {
	Version string `thrift:"1,required" json:"version"`
}

type CassandraSetCqlVersionResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraSetKeyspaceRequest struct {
	Keyspace string `thrift:"1,required" json:"keyspace"`
}

type CassandraSetKeyspaceResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
}

type CassandraSystemAddColumnFamilyRequest struct {
	CfDef *CfDef `thrift:"1,required" json:"cf_def"`
}

type CassandraSystemAddColumnFamilyResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraSystemAddKeyspaceRequest struct {
	KsDef *KsDef `thrift:"1,required" json:"ks_def"`
}

type CassandraSystemAddKeyspaceResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraSystemDropColumnFamilyRequest struct {
	ColumnFamily string `thrift:"1,required" json:"column_family"`
}

type CassandraSystemDropColumnFamilyResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraSystemDropKeyspaceRequest struct {
	Keyspace string `thrift:"1,required" json:"keyspace"`
}

type CassandraSystemDropKeyspaceResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraSystemUpdateColumnFamilyRequest struct {
	CfDef *CfDef `thrift:"1,required" json:"cf_def"`
}

type CassandraSystemUpdateColumnFamilyResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraSystemUpdateKeyspaceRequest struct {
	KsDef *KsDef `thrift:"1,required" json:"ks_def"`
}

type CassandraSystemUpdateKeyspaceResponse struct {
	Value string                      `thrift:"0" json:"value,omitempty"`
	Ire   *InvalidRequestException     `thrift:"1" json:"ire,omitempty"`
	Sde   *SchemaDisagreementException `thrift:"2" json:"sde,omitempty"`
}

type CassandraTraceNextQueryRequest struct {
}

type CassandraTraceNextQueryResponse struct {
	Value []byte `thrift:"0,required" json:"value"`
}

type CassandraTruncateRequest struct {
	Cfname string `thrift:"1,required" json:"cfname"`
}

type CassandraTruncateResponse struct {
	Ire *InvalidRequestException `thrift:"1" json:"ire,omitempty"`
	Ue  *UnavailableException    `thrift:"2" json:"ue,omitempty"`
	Te  *TimedOutException       `thrift:"3" json:"te,omitempty"`
}

type CassandraClient struct {
	Client RPCClient
}

func (s *CassandraClient) Add(Key []byte, ColumnParent *ColumnParent, Column *CounterColumn, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraAddRequest{
		Key:              Key,
		ColumnParent:     ColumnParent,
		Column:           Column,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraAddResponse{}
	err := s.Client.Call("add", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) AtomicBatchMutate(MutationMap map[string]map[string][]*Mutation, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraAtomicBatchMutateRequest{
		MutationMap:      MutationMap,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraAtomicBatchMutateResponse{}
	err := s.Client.Call("atomic_batch_mutate", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) BatchMutate(MutationMap map[string]map[string][]*Mutation, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraBatchMutateRequest{
		MutationMap:      MutationMap,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraBatchMutateResponse{}
	err := s.Client.Call("batch_mutate", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) Cas(Key []byte, ColumnFamily string, Expected []*Column, Updates []*Column, SerialConsistencyLevel ConsistencyLevel, CommitConsistencyLevel ConsistencyLevel) (*CASResult, error) {
	req := &CassandraCasRequest{
		Key:                    Key,
		ColumnFamily:           ColumnFamily,
		Expected:               Expected,
		Updates:                Updates,
		SerialConsistencyLevel: SerialConsistencyLevel,
		CommitConsistencyLevel: CommitConsistencyLevel,
	}
	res := &CassandraCasResponse{}
	err := s.Client.Call("cas", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeClusterName() (string, error) {
	req := &CassandraDescribeClusterNameRequest{}
	res := &CassandraDescribeClusterNameResponse{}
	err := s.Client.Call("describe_cluster_name", req, res)
	return res.Value, err
}

func (s *CassandraClient) DescribeKeyspace(Keyspace string) (*KsDef, error) {
	req := &CassandraDescribeKeyspaceRequest{
		Keyspace: Keyspace,
	}
	res := &CassandraDescribeKeyspaceResponse{}
	err := s.Client.Call("describe_keyspace", req, res)
	if err == nil {
		switch {
		case res.Nfe != nil:
			err = res.Nfe
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeKeyspaces() ([]*KsDef, error) {
	req := &CassandraDescribeKeyspacesRequest{}
	res := &CassandraDescribeKeyspacesResponse{}
	err := s.Client.Call("describe_keyspaces", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribePartitioner() (string, error) {
	req := &CassandraDescribePartitionerRequest{}
	res := &CassandraDescribePartitionerResponse{}
	err := s.Client.Call("describe_partitioner", req, res)
	return res.Value, err
}

func (s *CassandraClient) DescribeRing(Keyspace string) ([]*TokenRange, error) {
	req := &CassandraDescribeRingRequest{
		Keyspace: Keyspace,
	}
	res := &CassandraDescribeRingResponse{}
	err := s.Client.Call("describe_ring", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeSchemaVersions() (map[string][]string, error) {
	req := &CassandraDescribeSchemaVersionsRequest{}
	res := &CassandraDescribeSchemaVersionsResponse{}
	err := s.Client.Call("describe_schema_versions", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeSnitch() (string, error) {
	req := &CassandraDescribeSnitchRequest{}
	res := &CassandraDescribeSnitchResponse{}
	err := s.Client.Call("describe_snitch", req, res)
	return res.Value, err
}

func (s *CassandraClient) DescribeSplits(CfName string, StartToken string, EndToken string, KeysPerSplit int32) ([]string, error) {
	req := &CassandraDescribeSplitsRequest{
		CfName:       CfName,
		StartToken:   StartToken,
		EndToken:     EndToken,
		KeysPerSplit: KeysPerSplit,
	}
	res := &CassandraDescribeSplitsResponse{}
	err := s.Client.Call("describe_splits", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeSplitsEx(CfName string, StartToken string, EndToken string, KeysPerSplit int32) ([]*CfSplit, error) {
	req := &CassandraDescribeSplitsExRequest{
		CfName:       CfName,
		StartToken:   StartToken,
		EndToken:     EndToken,
		KeysPerSplit: KeysPerSplit,
	}
	res := &CassandraDescribeSplitsExResponse{}
	err := s.Client.Call("describe_splits_ex", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeTokenMap() (map[string]string, error) {
	req := &CassandraDescribeTokenMapRequest{}
	res := &CassandraDescribeTokenMapResponse{}
	err := s.Client.Call("describe_token_map", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) DescribeVersion() (string, error) {
	req := &CassandraDescribeVersionRequest{}
	res := &CassandraDescribeVersionResponse{}
	err := s.Client.Call("describe_version", req, res)
	return res.Value, err
}

func (s *CassandraClient) ExecuteCql3Query(Query []byte, Compression Compression, Consistency ConsistencyLevel) (*CqlResult, error) {
	req := &CassandraExecuteCql3QueryRequest{
		Query:       Query,
		Compression: Compression,
		Consistency: Consistency,
	}
	res := &CassandraExecuteCql3QueryResponse{}
	err := s.Client.Call("execute_cql3_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) ExecuteCqlQuery(Query []byte, Compression Compression) (*CqlResult, error) {
	req := &CassandraExecuteCqlQueryRequest{
		Query:       Query,
		Compression: Compression,
	}
	res := &CassandraExecuteCqlQueryResponse{}
	err := s.Client.Call("execute_cql_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) ExecutePreparedCql3Query(ItemId int32, Values [][]byte, Consistency ConsistencyLevel) (*CqlResult, error) {
	req := &CassandraExecutePreparedCql3QueryRequest{
		ItemId:      ItemId,
		Values:      Values,
		Consistency: Consistency,
	}
	res := &CassandraExecutePreparedCql3QueryResponse{}
	err := s.Client.Call("execute_prepared_cql3_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) ExecutePreparedCqlQuery(ItemId int32, Values [][]byte) (*CqlResult, error) {
	req := &CassandraExecutePreparedCqlQueryRequest{
		ItemId: ItemId,
		Values: Values,
	}
	res := &CassandraExecutePreparedCqlQueryResponse{}
	err := s.Client.Call("execute_prepared_cql_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) Get(Key []byte, ColumnPath *ColumnPath, ConsistencyLevel ConsistencyLevel) (*ColumnOrSuperColumn, error) {
	req := &CassandraGetRequest{
		Key:              Key,
		ColumnPath:       ColumnPath,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetResponse{}
	err := s.Client.Call("get", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Nfe != nil:
			err = res.Nfe
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) GetCount(Key []byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (int32, error) {
	req := &CassandraGetCountRequest{
		Key:              Key,
		ColumnParent:     ColumnParent,
		Predicate:        Predicate,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetCountResponse{}
	err := s.Client.Call("get_count", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) GetIndexedSlices(ColumnParent *ColumnParent, IndexClause *IndexClause, ColumnPredicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error) {
	req := &CassandraGetIndexedSlicesRequest{
		ColumnParent:     ColumnParent,
		IndexClause:      IndexClause,
		ColumnPredicate:  ColumnPredicate,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetIndexedSlicesResponse{}
	err := s.Client.Call("get_indexed_slices", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) GetPagedSlice(ColumnFamily string, Range *KeyRange, StartColumn []byte, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error) {
	req := &CassandraGetPagedSliceRequest{
		ColumnFamily:     ColumnFamily,
		Range:            Range,
		StartColumn:      StartColumn,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetPagedSliceResponse{}
	err := s.Client.Call("get_paged_slice", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) GetRangeSlices(ColumnParent *ColumnParent, Predicate *SlicePredicate, Range *KeyRange, ConsistencyLevel ConsistencyLevel) ([]*KeySlice, error) {
	req := &CassandraGetRangeSlicesRequest{
		ColumnParent:     ColumnParent,
		Predicate:        Predicate,
		Range:            Range,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetRangeSlicesResponse{}
	err := s.Client.Call("get_range_slices", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) GetSlice(Key []byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) ([]*ColumnOrSuperColumn, error) {
	req := &CassandraGetSliceRequest{
		Key:              Key,
		ColumnParent:     ColumnParent,
		Predicate:        Predicate,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraGetSliceResponse{}
	err := s.Client.Call("get_slice", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) Insert(Key []byte, ColumnParent *ColumnParent, Column *Column, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraInsertRequest{
		Key:              Key,
		ColumnParent:     ColumnParent,
		Column:           Column,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraInsertResponse{}
	err := s.Client.Call("insert", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) Login(AuthRequest *AuthenticationRequest) error {
	req := &CassandraLoginRequest{
		AuthRequest: AuthRequest,
	}
	res := &CassandraLoginResponse{}
	err := s.Client.Call("login", req, res)
	if err == nil {
		switch {
		case res.Authnx != nil:
			err = res.Authnx
		case res.Authzx != nil:
			err = res.Authzx
		}
	}
	return err
}

func (s *CassandraClient) MultigetCount(Keys [][]byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (map[string]int32, error) {
	req := &CassandraMultigetCountRequest{
		Keys:             Keys,
		ColumnParent:     ColumnParent,
		Predicate:        Predicate,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraMultigetCountResponse{}
	err := s.Client.Call("multiget_count", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) MultigetSlice(Keys [][]byte, ColumnParent *ColumnParent, Predicate *SlicePredicate, ConsistencyLevel ConsistencyLevel) (map[string][]*ColumnOrSuperColumn, error) {
	req := &CassandraMultigetSliceRequest{
		Keys:             Keys,
		ColumnParent:     ColumnParent,
		Predicate:        Predicate,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraMultigetSliceResponse{}
	err := s.Client.Call("multiget_slice", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return res.Value, err
}

func (s *CassandraClient) PrepareCql3Query(Query []byte, Compression Compression) (*CqlPreparedResult, error) {
	req := &CassandraPrepareCql3QueryRequest{
		Query:       Query,
		Compression: Compression,
	}
	res := &CassandraPrepareCql3QueryResponse{}
	err := s.Client.Call("prepare_cql3_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) PrepareCqlQuery(Query []byte, Compression Compression) (*CqlPreparedResult, error) {
	req := &CassandraPrepareCqlQueryRequest{
		Query:       Query,
		Compression: Compression,
	}
	res := &CassandraPrepareCqlQueryResponse{}
	err := s.Client.Call("prepare_cql_query", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return res.Value, err
}

func (s *CassandraClient) Remove(Key []byte, ColumnPath *ColumnPath, Timestamp int64, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraRemoveRequest{
		Key:              Key,
		ColumnPath:       ColumnPath,
		Timestamp:        Timestamp,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraRemoveResponse{}
	err := s.Client.Call("remove", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) RemoveCounter(Key []byte, Path *ColumnPath, ConsistencyLevel ConsistencyLevel) error {
	req := &CassandraRemoveCounterRequest{
		Key:              Key,
		Path:             Path,
		ConsistencyLevel: ConsistencyLevel,
	}
	res := &CassandraRemoveCounterResponse{}
	err := s.Client.Call("remove_counter", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}

func (s *CassandraClient) SetCqlVersion(Version string) error {
	req := &CassandraSetCqlVersionRequest{
		Version: Version,
	}
	res := &CassandraSetCqlVersionResponse{}
	err := s.Client.Call("set_cql_version", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return err
}

func (s *CassandraClient) SetKeyspace(Keyspace string) error {
	req := &CassandraSetKeyspaceRequest{
		Keyspace: Keyspace,
	}
	res := &CassandraSetKeyspaceResponse{}
	err := s.Client.Call("set_keyspace", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		}
	}
	return err
}

func (s *CassandraClient) SystemAddColumnFamily(CfDef *CfDef) (string, error) {
	req := &CassandraSystemAddColumnFamilyRequest{
		CfDef: CfDef,
	}
	res := &CassandraSystemAddColumnFamilyResponse{}
	err := s.Client.Call("system_add_column_family", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) SystemAddKeyspace(KsDef *KsDef) (string, error) {
	req := &CassandraSystemAddKeyspaceRequest{
		KsDef: KsDef,
	}
	res := &CassandraSystemAddKeyspaceResponse{}
	err := s.Client.Call("system_add_keyspace", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) SystemDropColumnFamily(ColumnFamily string) (string, error) {
	req := &CassandraSystemDropColumnFamilyRequest{
		ColumnFamily: ColumnFamily,
	}
	res := &CassandraSystemDropColumnFamilyResponse{}
	err := s.Client.Call("system_drop_column_family", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) SystemDropKeyspace(Keyspace string) (string, error) {
	req := &CassandraSystemDropKeyspaceRequest{
		Keyspace: Keyspace,
	}
	res := &CassandraSystemDropKeyspaceResponse{}
	err := s.Client.Call("system_drop_keyspace", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) SystemUpdateColumnFamily(CfDef *CfDef) (string, error) {
	req := &CassandraSystemUpdateColumnFamilyRequest{
		CfDef: CfDef,
	}
	res := &CassandraSystemUpdateColumnFamilyResponse{}
	err := s.Client.Call("system_update_column_family", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) SystemUpdateKeyspace(KsDef *KsDef) (string, error) {
	req := &CassandraSystemUpdateKeyspaceRequest{
		KsDef: KsDef,
	}
	res := &CassandraSystemUpdateKeyspaceResponse{}
	err := s.Client.Call("system_update_keyspace", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Sde != nil:
			err = res.Sde
		}
	}
	return res.Value, err
}

func (s *CassandraClient) TraceNextQuery() ([]byte, error) {
	req := &CassandraTraceNextQueryRequest{}
	res := &CassandraTraceNextQueryResponse{}
	err := s.Client.Call("trace_next_query", req, res)
	return res.Value, err
}

func (s *CassandraClient) Truncate(Cfname string) error {
	req := &CassandraTruncateRequest{
		Cfname: Cfname,
	}
	res := &CassandraTruncateResponse{}
	err := s.Client.Call("truncate", req, res)
	if err == nil {
		switch {
		case res.Ire != nil:
			err = res.Ire
		case res.Ue != nil:
			err = res.Ue
		case res.Te != nil:
			err = res.Te
		}
	}
	return err
}
